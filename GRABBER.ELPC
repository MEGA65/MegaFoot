' Grabber Tool - ported to Eleven (for easier maintenance)
' ------------
'
' Usage:
' -----
' - Press 'space' key on top-left point
' - Then use cursor keys to move to bottom-right point & press 'space'
' - Press '-' and '+' keys to move between previous and next frames
' - Press 'c' to redraw current frame
' - Press 'l' then a frame# to load that frame
' - Press 'x' to exit program
' - F1 = load char+color .bin file
' - F3 = save char+color .bin file
' - F5 = save optimized+repaired .bin file

#output "grabber"


'--------
.declares
'--------
#declare clr_line_right$ = chr$(27)+"q"   ' old cl$
#declare current_frame  ' old ff
#declare x, y  ' cursor position
#declare ptr  ' pointer to data bytes in memory
#declare frame_count
#declare frmidx
#declare bytes_used  ' old l
#declare frmw, frmh
#declare start_char, start_color, end_char, end_color
#declare startx, starty, endx, endy
#declare curr_frame
#declare clr_ptr
#declare a$, xidx, yidx
#declare dest_char_ptr, dest_clr_ptr
#declare fname$
#declare cval

#define STORE_START_POS = 0
#define STORE_END_POS = 1

#declare store_state  ' are we storing start/end pos char/colour details


'----
.main
'----
  key off
  poke $d020, 11, 14

  gosub init_vars
  gosub check_magic_signature

  gosub locate_next_free_byte

  gosub draw_footer

  do while 1
    gosub store_state_info
    gosub draw_cursor

    gosub read_input

    gosub show_coords
  loop


'-----------
.show_coords
'-----------
  cursor 0, 49
  print clr_line_right$;

  if store_state = STORE_START_POS then begin
    print chr$(27)+"qx=";x;", y=";y;
  bend

  if store_state = STORE_END_POS then begin
    print chr$(27)+"qx=";startx;", y=";starty;
    print ", w=";x-startx+1;", h=";y-starty+1;
  bend
  print clr_line_right$;
  return


'----------
.read_input
'----------
  getkey a$
  if a$ <> " " then gosub restore_char_under_cursor
  if a$ = "{x9D}" and x > 0 then x = x - 1
  if a$ = "{x1D}" and x < 79 then x = x + 1
  if a$ = "{x91}" and y > 0 then y = y - 1
  if a$ = "{x11}" and y < 49 then y = y + 1
  if a$ = "c" then begin
    print "{x93}";
    curr_frame = 0
    gosub draw_curr_frame
  bend
  if a$="-" and curr_frame > 0 then begin
    curr_frame = curr_frame - 1
    gosub draw_curr_frame
  bend
  if a$="=" and curr_frame < peek($42000)-1 then begin
    curr_frame = curr_frame + 1
    gosub draw_curr_frame
  bend
  if a$=" " then begin
    store_state = store_state + 1
    if store_state = 2 then begin
      gosub save_frame_to_memory
      end
    bend
  bend
  if a$="l" then gosub load_frame
  if a$="x" then begin
    cursor 0,0
    key on
    end
  bend
  if a$="{x85}" then gosub load_bin
  if a$="{x86}" then gosub save_bin
  if a$="{x87}" then gosub save_optimised

  return


'--------
.load_bin
'--------
  input "load name: ";fname$
  if fname$ = "" then return

  bload (fname$),p($42000)
  return


'--------
.save_bin
'--------
  input "save name: ";fname$
  if fname$ = "" then return

  gosub locate_next_free_byte
  delete (fname$)
  bsave (fname$),p($42000) to p(ptr)
  return


'--------------
.save_optimised
'--------------
  input "save name (optimised): ";fname$
  if fname$ = "" then return

  delete (fname$)

  ptr = $42001
  dopen #2,(fname$ + ",p"),w,u8
  print #2, chr$(1);
  print #2, chr$(2);  ' dummy address
  print #2, chr$(frame_count);

  for frmidx = 0 to frame_count - 1
    x = peek(ptr)
    ptr = ptr + 1
    y = peek(ptr)
    ptr = ptr + 1
    frmw = peek(ptr)
    ptr = ptr + 1
    frmh = peek(ptr)
    ptr = ptr + 1

    print #2, chr$(x);chr$(y);chr$(frmw);chr$(frmh);

    endx = x + frmw - 1
    endy = y + frmh - 1

    clr_ptr = ptr + frmw * frmh
    
    for yidx = 0 to endy - y
      for xidx = 0 to endx - x
        cval = peek(clr_ptr + xidx + yidx * frmw)
        if peek(ptr + xidx + yidx * frmw) = 32 then begin
          cval = $ff
        bend
        print #2, chr$(cval);
      next xidx
    next yidx

    ptr = ptr + frmw * frmh * 2

  next frmidx

  dclose #2
  return


'--------------------
.save_frame_to_memory
'--------------------
  poke $40800 + startx + starty * 80, start_char
  poke $ff80000 + startx + starty * 80, start_color

  poke $40800 + endx + endy * 80, end_char
  poke $ff80000 + endx + endy * 80, end_color

  frame_count = peek($42000)
  gosub locate_next_free_byte

  ptr = $42000 + bytes_used
  poke ptr, startx
  ptr = ptr + 1
  poke ptr, starty
  ptr = ptr + 1
  poke ptr, x - startx + 1
  ptr = ptr + 1
  poke ptr, y - starty + 1
  ptr = ptr + 1

  for yidx = starty to y
    for xidx = startx to x
     poke ptr, peek($40800 + xidx + yidx * 80)
     ptr = ptr + 1
    next xidx
  next yidx

  for yidx = starty to y
    for xidx = startx to x
     poke ptr, peek($ff80000 + xidx + yidx * 80)
     ptr = ptr + 1
    next xidx
  next yidx

  poke $42000, frame_count + 1

  cursor 0,49
  print clr_line_right$;"frame count=";peek($42000);
  print ", next-free=$";hex$(ptr);
  cursor 0,0

  return


'----------
.load_frame
'----------
  print "{x13}";clr_line_right$;
  input "frame#";curr_frame
  gosub draw_curr_frame
  return

'---------------
.draw_curr_frame
'---------------
  frame_count = peek($42000)
  ptr = $42001
  frmidx = 0
  if frmidx >= frame_count then begin
    cursor 0,0
    print clr_line_right$;"invalid block#!"
    return
  bend

  ' traverse to find block
  do while 1
    if frmidx = curr_frame then goto _found_it
    ' skip x, y
    ptr = ptr + 2
    frmw = peek(ptr)
    ptr = ptr + 1
    frmh = peek(ptr)
    ptr = ptr + 1

    ptr = ptr + frmw * frmh * 2

    frmidx = frmidx + 1
  loop
  
._found_it
  x = peek(ptr)
  ptr = ptr + 1
  y = peek(ptr)
  ptr = ptr + 1
  frmw = peek(ptr)
  ptr = ptr + 1
  frmh = peek(ptr)
  ptr = ptr + 1

  endx = x + frmw - 1
  endy = y + frmh - 1

  print "{x13}";clr_line_right$;
  print "x=";x;", y=";y;", w=";frmw;", h=";frmh;
  print ", ptr=$";hex$(ptr);
  print "{x11}";chr$(27);"j";clr_line_right$;"frame=";curr_frame;
  print ", nxt=$";hex$(ptr + frmw * frmh * 2);

  clr_ptr = ptr + frmw * frmh

  dest_char_ptr =$40800 + x + y * 80
  dest_clr_ptr = $ff80000 + x + y * 80

  for yidx = y to endy
    edma 0, frmw, ptr, dest_char_ptr
    edma 0, frmw, clr_ptr, dest_clr_ptr
    ptr = ptr + frmw
    clr_ptr = clr_ptr + frmw
    dest_char_ptr = dest_char_ptr + 80
    dest_clr_ptr = dest_clr_ptr + 80
  next yidx

  return


'-------------------------
.restore_char_under_cursor
'-------------------------
  if store_state = STORE_START_POS then begin
    poke $40800 + x + y * 80, start_char
    poke $ff80000 + x + y * 80, start_color
  bend:else begin  ' STORE_END_POS
    poke $40800 + x + y * 80, end_char
    poke $ff80000 + x + y * 80, end_color      
  bend
  return


'-----------
.draw_cursor
'-----------
  poke $40800 + x + y * 80, 43
  poke $ff80000 + x + y * 80, 1
  return

'-----------
.draw_footer
'-----------
  cursor 0,49
  print clr_line_right$;"frame count=";peek($42000);", next-free=$";
  print hex$(ptr);
  return


'----------------
.store_state_info
'----------------
  if store_state = STORE_START_POS then begin
    start_char = peek($40800 + x + y * 80)
    start_color = peek($ff80000 + x + y * 80)
    startx = x
    starty = y
  bend:else begin ' STORE_END_POS
    end_char = peek($40800 + x + y * 80)
    end_color = peek($ff80000 + x + y * 80)
    endx = x
    endy = y
  bend
  return


'---------
.init_vars
'---------
  current_frame = 0
  store_state = STORE_START_POS
  x = 0
  y = 0
  curr_frame = 0

  return  


'---------------------
.locate_next_free_byte
'---------------------
  frame_count = peek($42000)
  ptr = $42001
  frmidx = 0

  do while 1

    if frmidx = frame_count then begin
      bytes_used = ptr-$42000
      return
    bend

    ptr = ptr + 2  ' skip x, y info
    frmw = peek(ptr) : ptr = ptr + 1
    frmh = peek(ptr) : ptr = ptr + 1

    ptr = ptr + frmw * frmh * 2
    frmidx = frmidx + 1

  loop

  return


'---------------------
.check_magic_signature
'---------------------
  if peek($5fffe) <> 71 or peek($5ffff) <> 73 then begin
    wpoke $5fffe, $4947
    print "{x93}";clr_line_right$;
    print "magic signature applied. reset frame count to zero? (y/n)";
    get key a$
    if a$ = "y" then poke $42000,0
    print "{x93}";clr_line_right$;
  bend
  return
ÿ