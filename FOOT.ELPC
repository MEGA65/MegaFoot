' Way of the Imploding Foot
' -------------------------
' A collaborative team-effort game made by the MEGA65 community
'
' Gurce:
' -----
' - Initial background art
' - Eleven code infrastructure
' - Initial Game mechanics
' Deft:
' ----
' - Artistic player head permutations

#output "foot"

' BANK4 Memory usage
' ------------------
' 4.0000 DMA-LIST
' 4.0100 SUNSET PALETTES (each palette is 16*3 in size, have 12 palettes)
' 4.0800 SCREEN MEMORY
' 4.2000 PETSCII GRAPHICS

' BANK5 Memory usage
' ------------------
' 5.0000 screen buffer
' 5.1000 color ram buffer
' 5.2000 doubled-up layer buffer

' uncomment this line to add debug output
#declare DEBUG = 0

.petscii vars
'------------
#define FORM_LAYER   = 0
#define FORM_HUMAN   = 1
#define FORM_DUCK    = 2
#define FORM_MAX     = 3

#define DAT_LAYER   = 0
#define DAT_PLAYER1 = 1
#define DAT_PLAYER2 = 2
#define DAT_PLAYER3 = 3
#define DAT_PLAYER4 = 4
#define DAT_DUCK    = 5
#define DAT_MAX     = 6

#declare data_addr = $42000
#declare max_frames(FORM_MAX)
#declare frame_addr(DAT_MAX, 25)
#declare frame_dblup_addr(64)

#declare jdir_raw, jfire, jdir

#declare frm_idx = 0
#declare frmw, frmh,frmx,frmy,frmx1,frmy1,frameidx,cdata_addr
#declare yy, scraddr,clraddr
#declare a$, lidx, k, x, y
#declare src_addr, dest_addr, length, transp
#declare dest_mb_sel, dest_bank
#declare form, sz

#define PLAYER = 0
#define BADDIE = 1
#declare character

#declare opponent_data_addr

#declare dblup_addr = $52000

#declare kneel_flag
#declare baddie_kneel_flag

#declare mirror, player_mirror, baddie_mirror, opponent_mirror, tmp_mirror

#declare px, py ' player x,y
#declare bx, by ' baddie x,y

#declare player_energy = 18
#declare lag_penergy = 0
#declare baddie_energy = 18
#declare lag_benergy = 0

#declare x1,y1,x2,y2, draw_color, idx, tmpx1
#declare p_x1, p_y1, p_x2, p_y2
#declare o_x1, o_y1, o_x2, o_y2
#declare ret%
#declare dat_idx, player_dat_idx, baddie_dat_idx
#declare player_dat_fixed, baddie_dat_fixed
#declare tmp

#define CHAR_BOX_TL = 112
#define CHAR_BOX_TR = 110
#define CHAR_BOX_BL = 109
#define CHAR_BOX_BR = 125
#define CHAR_HORZ   = 64
#define CHAR_VERT   = 93
#define CHAR_SPACE  = 32


.joystick_defs
'-------------
#define J_UP = 1
#define J_UP_RIGHT = 2
#define J_RIGHT = 3
#define J_DOWN_RIGHT = 4
#define J_DOWN = 5
#define J_DOWN_LEFT = 6
#define J_LEFT = 7
#define J_UP_LEFT = 8
#define J_FIRE = 128

#define JD_UP = 1
#define JD_UP_FORWARD = 2
#define JD_FORWARD = 3
#define JD_DOWN_FORWARD = 4
#define JD_DOWN = 5
#define JD_DOWN_BACKWARD = 6
#define JD_BACKWARD = 7
#define JD_UP_BACKWARD = 8

#declare jd(1,8) ' directional joystick (player direction neutral)
jd(0, J_UP) = JD_UP
jd(0, J_UP_RIGHT) = JD_UP_FORWARD
jd(0, J_RIGHT) = JD_FORWARD
jd(0, J_DOWN_RIGHT) = JD_DOWN_FORWARD
jd(0, J_DOWN) = JD_DOWN
jd(0, J_DOWN_LEFT) = JD_DOWN_BACKWARD
jd(0, J_LEFT) = JD_BACKWARD
jd(0, J_UP_LEFT) = JD_UP_BACKWARD

jd(1, J_UP) = JD_UP
jd(1, J_UP_RIGHT) = JD_UP_BACKWARD
jd(1, J_RIGHT) = JD_FORWARD
jd(1, J_DOWN_RIGHT) = JD_DOWN_BACKWARD
jd(1, J_DOWN) = JD_DOWN
jd(1, J_DOWN_LEFT) = JD_DOWN_FORWARD
jd(1, J_LEFT) = JD_FORWARD
jd(1, J_UP_LEFT) = JD_UP_FORWARD


.imgs
'----
#define IMG_CLOUDS = 0
#define IMG_SKY = 1
#define IMG_LT_MOUNT = 2
#define IMG_DK_MOUNT = 3
#define IMG_WATER = 4
#define IMG_HI_GROUND = 5
#define IMG_LO_GROUND = 6
#define IMG_SUN = 7

#define IMG_PWALK1 = 0
#define IMG_PWALK2 = 1
#define IMG_PWALK3 = 2
#define IMG_PPUNCH1 = 3
#define IMG_PPUNCH2 = 4
#define IMG_PPUNCH3 = 5
#define IMG_PKICK1 = 6
#define IMG_PKICK2 = 7
#define IMG_PKICK3 = 8
#define IMG_PKNEEL1 = 9
#define IMG_PKNEEL2 = 10
#define IMG_PKNEEL3 = 11
#define IMG_PKPUNCH1 = 12
#define IMG_PKPUNCH2 = 13
#define IMG_PKPUNCH3 = 14
#define IMG_PKKICK1 = 15
#define IMG_PKKICK2 = 16
#define IMG_PKKICK3 = 17
#define IMG_PDIE1 = 18
#define IMG_PDIE2 = 19
#define IMG_PDIE3 = 20
#define IMG_PDIE4 = 21
#define IMG_PDIE5 = 22

#define IMG_DWALK1 = 0
#define IMG_DWALK2 = 1
#define IMG_DWALK3 = 2
#define IMG_DQUACK1 = 3
#define IMG_DQUACK2 = 4
#define IMG_DQUACK3 = 5
#define IMG_DDIE1 = 6
#define IMG_DDIE2 = 7
#define IMG_DDIE3 = 8
#define IMG_DDIE4 = 9
#define IMG_DDIE5 = 10


#define HIGHEST_LAYER = 7

#declare fx, fy

#declare xoffs(HIGHEST_LAYER) ' offset into cycling of graphic

#declare draw_order(HIGHEST_LAYER)
draw_order(0) = IMG_SKY
draw_order(1) = IMG_SUN
draw_order(2) = IMG_CLOUDS
draw_order(3) = IMG_LT_MOUNT
draw_order(4) = IMG_DK_MOUNT
draw_order(5) = IMG_WATER
draw_order(6) = IMG_HI_GROUND
draw_order(7) = IMG_LO_GROUND

#declare offs_amount(HIGHEST_LAYER)
offs_amount(0) = .7
offs_amount(1) = 0
offs_amount(2) = .1
offs_amount(3) = .5
offs_amount(4) = 1
offs_amount(5) = 1.5
offs_amount(6) = 2

#declare palidx, ptr

.anims
'-----
#define ANIM_PWALK = 0
#define ANIM_PPUNCH = 1
#define ANIM_PKICK = 2
#define ANIM_PKNEEL_DN = 3
#define ANIM_PKNEEL_UP = 4
#define ANIM_PKPUNCH = 5
#define ANIM_PKKICK = 6
#define ANIM_PDIE = 7
#define ANIM_PJUMP = 8

#define ANIM_DWALK = 0
#define ANIM_DQUACK = 1
#define ANIM_DDIE = 2

#define ANIM_MAX = 10

#declare anim_order(FORM_MAX, ANIM_MAX, 10)
anim_order(FORM_HUMAN, ANIM_PWALK, 0) = IMG_PWALK1
anim_order(FORM_HUMAN, ANIM_PWALK, 1) = IMG_PWALK2
anim_order(FORM_HUMAN, ANIM_PWALK, 2) = IMG_PWALK3
anim_order(FORM_HUMAN, ANIM_PWALK, 3) = IMG_PWALK2

anim_order(FORM_HUMAN, ANIM_PPUNCH, 0) = IMG_PPUNCH1
anim_order(FORM_HUMAN, ANIM_PPUNCH, 1) = IMG_PPUNCH2
anim_order(FORM_HUMAN, ANIM_PPUNCH, 2) = IMG_PPUNCH3
anim_order(FORM_HUMAN, ANIM_PPUNCH, 3) = IMG_PPUNCH2
anim_order(FORM_HUMAN, ANIM_PPUNCH, 4) = IMG_PPUNCH1

anim_order(FORM_HUMAN, ANIM_PKICK, 0) = IMG_PKICK1
anim_order(FORM_HUMAN, ANIM_PKICK, 1) = IMG_PKICK2
anim_order(FORM_HUMAN, ANIM_PKICK, 2) = IMG_PKICK3
anim_order(FORM_HUMAN, ANIM_PKICK, 3) = IMG_PKICK2
anim_order(FORM_HUMAN, ANIM_PKICK, 4) = IMG_PKICK1

anim_order(FORM_HUMAN, ANIM_PKNEEL_DN, 0) = IMG_PKNEEL1
anim_order(FORM_HUMAN, ANIM_PKNEEL_DN, 1) = IMG_PKNEEL2
anim_order(FORM_HUMAN, ANIM_PKNEEL_DN, 2) = IMG_PKNEEL3

anim_order(FORM_HUMAN, ANIM_PKNEEL_UP, 0) = IMG_PKNEEL2
anim_order(FORM_HUMAN, ANIM_PKNEEL_UP, 1) = IMG_PKNEEL1

anim_order(FORM_HUMAN, ANIM_PKPUNCH, 0) = IMG_PKPUNCH1
anim_order(FORM_HUMAN, ANIM_PKPUNCH, 1) = IMG_PKPUNCH2
anim_order(FORM_HUMAN, ANIM_PKPUNCH, 2) = IMG_PKPUNCH3
anim_order(FORM_HUMAN, ANIM_PKPUNCH, 3) = IMG_PKPUNCH2
anim_order(FORM_HUMAN, ANIM_PKPUNCH, 4) = IMG_PKPUNCH1

anim_order(FORM_HUMAN, ANIM_PKKICK, 0) = IMG_PKKICK1
anim_order(FORM_HUMAN, ANIM_PKKICK, 1) = IMG_PKKICK2
anim_order(FORM_HUMAN, ANIM_PKKICK, 2) = IMG_PKKICK3
anim_order(FORM_HUMAN, ANIM_PKKICK, 3) = IMG_PKKICK2
anim_order(FORM_HUMAN, ANIM_PKKICK, 4) = IMG_PKKICK1

anim_order(FORM_HUMAN, ANIM_PDIE, 0) = IMG_PDIE1
anim_order(FORM_HUMAN, ANIM_PDIE, 1) = IMG_PDIE2
anim_order(FORM_HUMAN, ANIM_PDIE, 2) = IMG_PDIE3
anim_order(FORM_HUMAN, ANIM_PDIE, 3) = IMG_PDIE4
anim_order(FORM_HUMAN, ANIM_PDIE, 4) = IMG_PDIE5
anim_order(FORM_HUMAN, ANIM_PDIE, 5) = IMG_PDIE5
anim_order(FORM_HUMAN, ANIM_PDIE, 6) = IMG_PDIE5
anim_order(FORM_HUMAN, ANIM_PDIE, 7) = IMG_PDIE5
anim_order(FORM_HUMAN, ANIM_PDIE, 8) = IMG_PDIE5

anim_order(FORM_HUMAN, ANIM_PJUMP, 0) = IMG_PKNEEL1
anim_order(FORM_HUMAN, ANIM_PJUMP, 1) = IMG_PKNEEL2

anim_order(FORM_DUCK, ANIM_DWALK, 0) = IMG_DWALK1
anim_order(FORM_DUCK, ANIM_DWALK, 1) = IMG_DWALK2
anim_order(FORM_DUCK, ANIM_DWALK, 2) = IMG_DWALK3
anim_order(FORM_DUCK, ANIM_DWALK, 3) = IMG_DWALK2

anim_order(FORM_DUCK, ANIM_DQUACK, 0) = IMG_DQUACK1
anim_order(FORM_DUCK, ANIM_DQUACK, 1) = IMG_DQUACK2
anim_order(FORM_DUCK, ANIM_DQUACK, 2) = IMG_DQUACK3
anim_order(FORM_DUCK, ANIM_DQUACK, 3) = IMG_DQUACK2
anim_order(FORM_DUCK, ANIM_DQUACK, 4) = IMG_DQUACK1

anim_order(FORM_DUCK, ANIM_DDIE, 0) = IMG_DDIE1
anim_order(FORM_DUCK, ANIM_DDIE, 1) = IMG_DDIE2
anim_order(FORM_DUCK, ANIM_DDIE, 2) = IMG_DDIE3
anim_order(FORM_DUCK, ANIM_DDIE, 3) = IMG_DDIE4
anim_order(FORM_DUCK, ANIM_DDIE, 4) = IMG_DDIE5
anim_order(FORM_DUCK, ANIM_DDIE, 5) = IMG_DDIE5
anim_order(FORM_DUCK, ANIM_DDIE, 6) = IMG_DDIE5
anim_order(FORM_DUCK, ANIM_DDIE, 7) = IMG_DDIE5
anim_order(FORM_DUCK, ANIM_DDIE, 8) = IMG_DDIE5


#declare max_frame(FORM_MAX, ANIM_MAX)
max_frame(FORM_HUMAN, ANIM_PWALK) = 4
max_frame(FORM_HUMAN, ANIM_PPUNCH) = 5
max_frame(FORM_HUMAN, ANIM_PKICK) = 5
max_frame(FORM_HUMAN, ANIM_PKNEEL_DN) = 3
max_frame(FORM_HUMAN, ANIM_PKNEEL_UP) = 2
max_frame(FORM_HUMAN, ANIM_PKPUNCH) = 5
max_frame(FORM_HUMAN, ANIM_PKKICK) = 5
max_frame(FORM_HUMAN, ANIM_PDIE) = 9
max_frame(FORM_HUMAN, ANIM_PJUMP) = 2

max_frame(FORM_DUCK, ANIM_DWALK) = 4
max_frame(FORM_DUCK, ANIM_DQUACK) = 5
max_frame(FORM_DUCK, ANIM_DDIE) = 9

.fanim
#declare player_form = 1 ' HUMAN
#declare baddie_form = 1

#define FANIM_WALK = 0
#define FANIM_PUNCH = 1
#define FANIM_KICK = 2
#define FANIM_KNEEL_DN = 3
#define FANIM_KNEEL_UP = 4
#define FANIM_KPUNCH = 5
#define FANIM_KKICK = 6
#define FANIM_DIE = 7
#define FANIM_JUMP = 8

#define FANIM_MAX = 9

#declare form_anim(FORM_MAX, FANIM_MAX)
form_anim(FORM_HUMAN, FANIM_WALK) = ANIM_PWALK
form_anim(FORM_HUMAN, FANIM_PUNCH) = ANIM_PPUNCH
form_anim(FORM_HUMAN, FANIM_KICK) = ANIM_PKICK
form_anim(FORM_HUMAN, FANIM_KNEEL_DN) = ANIM_PKNEEL_DN
form_anim(FORM_HUMAN, FANIM_KNEEL_UP) = ANIM_PKNEEL_UP
form_anim(FORM_HUMAN, FANIM_KPUNCH) = ANIM_PKPUNCH
form_anim(FORM_HUMAN, FANIM_KKICK) = ANIM_PKKICK
form_anim(FORM_HUMAN, FANIM_DIE) = ANIM_PDIE
form_anim(FORM_HUMAN, FANIM_JUMP) = ANIM_PJUMP

form_anim(FORM_DUCK, FANIM_WALK) = ANIM_DWALK
form_anim(FORM_DUCK, FANIM_PUNCH) = ANIM_DQUACK
form_anim(FORM_DUCK, FANIM_KICK) = ANIM_DQUACK
form_anim(FORM_DUCK, FANIM_DIE) = ANIM_DDIE

#declare player_frame = 0
#declare player_anim = 0 ' ANIM_PWALK

#declare baddie_frame = 0
#declare baddie_anim = 0 ' ANIM_PWALK

.offsets
#define OFFSET_DATA_SIZE  = 0
#define OFFSET_NUM_FRAMES = 2
#define OFFSET_FRAME0     = 3

#define FRM_OFFSET_X          = 0
#define FRM_OFFSET_Y          = 1
#define FRM_OFFSET_W          = 2
#define FRM_OFFSET_H          = 3
#define FRM_OFFSET_HITBOXES   = 4
#define FRM_OFFSET_HB_HEAD    = 4
#define FRM_OFFSET_HB_TORSO   = 8
#define FRM_OFFSET_HB_FEET    = 12
#define FRM_OFFSET_HB_ATTACK  = 16
#define FRM_OFFSET_DATA       = 20

#declare bx_offs(3)
bx_offs(0) = FRM_OFFSET_HB_HEAD
bx_offs(1) = FRM_OFFSET_HB_TORSO
bx_offs(2) = FRM_OFFSET_HB_FEET
bx_offs(3) = FRM_OFFSET_HB_ATTACK

.music_vars
'----------
#define chunk_max = 50
#declare chunk_cnt, chunk_idx, vidx, tmpo%, row
#declare echo_m, echo_b, echo_sz = .05, chunk_rpt, echo_delay
#declare v$(5,chunk_max), v
#declare song$
#declare v1$, v2$, v3$, v4$, v5$, v6$
#declare curr_freq, curr_dir

#struct ENVTYPE name$, attack, decay, sustain, release, waveform, pw

ENVTYPE envs(9) = [ {x5F}
  [ "Piano",       0,  9,  0,  0,  2, 1536 ], {x5F}
  [ "Accordion",  12,  0, 12,  0,  1,    0 ], {x5F}
  [ "Calliope",    0,  0, 15,  0,  0,    0 ], {x5F}
  [ "Drum",        0,  5,  5,  0,  3,    0 ], {x5F}
  [ "Flute",       9,  4,  4,  0,  0,    0 ], {x5F}
  [ "Guitar",      0,  9,  2,  1,  1,    0 ], {x5F}
  [ "Harpsicrd",   0,  9,  0,  0,  2,  512 ], {x5F}
  [ "Organ",       0,  9,  9,  0,  2, 2048 ], {x5F}
  [ "Trumpet",     8,  9,  4,  1,  2,  512 ], {x5F}
  [ "Xylophone",   0,  9,  0,  0,  0,    0 ]  {x5F}
]

#define DIR_NONE = 0
#define DIR_UP   = 1
#define DIR_DOWN = 2
#define DIR_OSC  = 3

#define F_OFF = 0
#define F_ON  = 1

#declare fsrow = 0, fsel = -1

#struct FILTTYPE name$, freq, lp, bp, hp, res, dir, min, sweep

FILTTYPE filt(10) = [ {x5F}
  [ "lowp_up",    1000, F_ON,  F_OFF, F_OFF, 15, DIR_UP,   100, 10 ], {x5F}
  [ "lowp_down",  1000, F_ON,  F_OFF, F_OFF, 15, DIR_DOWN, 100, 10 ], {x5F}
  [ "lowp_osc",   1000, F_ON,  F_OFF, F_OFF, 15, DIR_OSC,  100, 10 ], {x5F}
{x5F}
  [ "bandp_up",   1000, F_OFF, F_ON,  F_OFF, 15, DIR_UP,   100, 10 ], {x5F}
  [ "bandp_down", 1000, F_OFF, F_ON,  F_OFF, 15, DIR_DOWN, 100, 10 ], {x5F}
  [ "bandp_osc",  1000, F_OFF, F_ON,  F_OFF, 15, DIR_OSC,  100, 10 ], {x5F}
{x5F}
  [ "highp_up",   1000, F_OFF, F_OFF, F_ON,  15, DIR_UP,   100, 10 ], {x5F}
  [ "highp_down", 1000, F_OFF, F_OFF, F_ON,  15, DIR_DOWN, 100, 10 ], {x5F}
  [ "highp_osc",  1000, F_OFF, F_OFF, F_ON,  15, DIR_OSC,  100, 10 ], {x5F}
{x5F}
  [ "spare_1",    0,    F_OFF, F_OFF, F_OFF, 0,  DIR_NONE, 0,   0  ], {x5F}
  [ "spare_2",    0,    F_OFF, F_OFF, F_OFF, 0,  DIR_NONE, 0,   0  ], {x5F}
{x5F}
]

#declare seqcnt
#declare seq_chunk(200), seq_extra(200)

#declare plyptr, plyflag

#define CMD_TEMPO = -1
#define CMD_FILTER = -2
#define CMD_LOOP = -3
#define CMD_ECHO_M1 = -4   ' echo melody: voice 1 on voice 4
#define CMD_ECHO_M2 = -5   ' echo melody: voice 1 on voice 2 + 4 + 5
#define CMD_ECHO_B  = -6   ' echo bass:   voice 3 on voice 6
#define CMD_ECHO_OFF = -7
#define CMD_ECHO_SZ = -8
#define CMD_VOL = -9
#define CMD_DELAY = -10
#define CMD_MAX = 11

#declare pjump, bjump

#define BS_OFF = 0
#define BS_SPAWN = 1
#define BS_ALIVE = 2
#define BS_DEAD = 3

#declare next_baddie_time = 50, baddie_dead_time = 50, baddie_state
#declare baddie_visible

'----
.main
'----
print chr$(27)+"5"
print chr$(147);
border 0
background 0
gosub load_data
palidx = 0
gosub set_palette

song$ = "chabi.p"
gosub load_song

.loop0
  gosub init_vars
  gosub show_title
  gosub gameplay
  ' gosub gameover
  goto loop0

'---------------
.transparent_dma
'---------------
  wpoke $40009, src_addr
  wpoke $4000c, dest_addr
  wpoke $40007, length
  poke  $40004, transp
  poke $d702, 4 ' dma list in bank 4
  poke $d701, $00 ' dma list msb
  poke $d705, $00 ' dma list lsb

  return


'----------
.show_title
'----------
  print chr$(147);
  print chr$(14);  ' lower-case
  print "Way of the Imploding Foot"
  print "========================="
  print "A game made by the MEGA65 community!"
  get key a$
  a$=""

  ' all reverse-char spaces for most of screen
  edma 3, $f00, 160, $40800
  print chr$(142);  ' uppercase

  return


'---------
.load_data
'---------
  ptr = $42000
  
  form = FORM_LAYER
  dat_idx = DAT_LAYER
  bload "level1-bg.dat",p(ptr)
  gosub init_petscii_frames
  gosub prepare_double_copy_layer
  gosub _increment_ptr_to_next_free

  form = FORM_HUMAN
  dat_idx = DAT_PLAYER1
  bload "player.dat",p(ptr)
  gosub init_petscii_frames
  gosub _increment_ptr_to_next_free

  form = FORM_HUMAN
  dat_idx = DAT_PLAYER2
  bload "player2.dat",p(ptr)
  gosub init_petscii_frames
  gosub _increment_ptr_to_next_free

  form = FORM_HUMAN
  dat_idx = DAT_PLAYER3
  bload "player3.dat",p(ptr)
  gosub init_petscii_frames
  gosub _increment_ptr_to_next_free

  form = FORM_HUMAN
  dat_idx = DAT_PLAYER4
  bload "player4.dat",p(ptr)
  gosub init_petscii_frames
  gosub _increment_ptr_to_next_free

  form = FORM_DUCK
  dat_idx = DAT_DUCK
  bload "duck.dat",p(ptr)
  gosub init_petscii_frames
  gosub _increment_ptr_to_next_free

  bload "pal.bin",p($40100),r
  return


'---------------------------
._increment_ptr_to_next_free
'---------------------------
  ptr = tmp
  sz = wpeek(ptr + OFFSET_DATA_SIZE)
  'print
  'print "inc sz = ";sz
  'print "ptr = ";hex$(ptr + OFFSET_DATA_SIZE)
  ptr = ptr + sz

  'get key a$
  return

'-----------
.set_palette
'----------- (palidx)
  ptr = $40100 + palidx * 16 * 3

  for k = 0 to 15
    ' red
    poke $d100 + k + 16, peek(ptr)
    ptr = ptr + 1

    ' green
    poke $d200 + k + 16, peek(ptr)
    ptr = ptr + 1

    ' blue
    poke $d300 + k + 16, peek(ptr)
    ptr = ptr + 1
  next k
  return

'---------
.init_vars
'---------
  ' clear dma list area

  for k = 0 to 20
    poke $40000+k, 0
  next k

  poke $40000, $81 ' opt = dest addr MB selector
  poke $40001, $00 ' default to 1st megabyte

  poke $40002, $07 ' opt = enable transparency
  poke $40003, $86 ' opt = set transparency
  poke $40004, $20 ' transparency value
  poke $40005, $00 ' end of options

  poke $40006, $00 ' CMD lsb = COPY
  wpoke $40007, $0000 ' length
  wpoke $40009, $1000 ' source addr
  poke $4000b, $05    ' source bank
  wpoke $4000c, $1000 ' dest addr
  poke $4000e, $05    ' dest bank
  poke $4000f, $00    ' CMD msb (ignore)
  wpoke $40010, $0000 ' modulo (ignore)

  ' clear the offscreen buffer
  edma 3, $f00, 160, $50000
  edma 3, $a0, $20, $50f00
  edma 3, $fa0, $4f, $51000

  kneel_flag = 0
  player_form = FORM_HUMAN
  player_dat_fixed = DAT_PLAYER4
  player_dat_idx = player_dat_fixed

  baddie_kneel_flag = 0
  baddie_form = FORM_HUMAN
  baddie_dat_fixed = DAT_PLAYER2
  baddie_dat_idx = baddie_dat_fixed

  player_frame = 0
  player_anim = form_anim(player_form, FANIM_WALK)
  px = 0 : py = 23
  bx = 60 : by = 23

  player_energy = 18
  lag_penergy = 0
  baddie_energy = 0
  lag_benergy = 0
  pjump = 0

  player_mirror = 0
  baddie_mirror = 1
  bjump = 0

  next_baddie_time = 50
  baddie_dead_time = 50
  baddie_state = BS_OFF

  return

'-------------------
.init_petscii_frames
'-------------------
  tmp = ptr
  max_frames(form) = peek(ptr + OFFSET_NUM_FRAMES)
  'print
  'print "ptr=";hex$(ptr + OFFSET_NUM_FRAMES)
  ptr = ptr + OFFSET_FRAME0

  'print
  'print "form=";form;" - mx_frm=";max_frames(form);": ";

  frm_idx = 0
  do while frm_idx < max_frames(form)
    'print frm_idx;
    frame_addr(dat_idx, frm_idx) = ptr
    frmw = peek(ptr + FRM_OFFSET_W)
    frmh = peek(ptr + FRM_OFFSET_H)
    
    'print "ptr=";hex$(ptr);", idx=";frm_idx;", w=";frmw;", h=";frmh
    ptr = ptr + FRM_OFFSET_DATA + frmw * frmh

    ':print chr$(147);"frm_idx=";frm_idx

    frm_idx = frm_idx + 1
  loop

  ptr = tmp
  return


'-------------------------
.prepare_double_copy_layer
'-------------------------
  dblup_addr = $52000

  for frameidx = 0 to max_frames(FORM_LAYER)-1
    ptr = frame_addr(DAT_LAYER, frameidx)
    frmx = peek(ptr + FRM_OFFSET_X)
    frmy = peek(ptr + FRM_OFFSET_Y)
    frmw = peek(ptr + FRM_OFFSET_W)
    frmh = peek(ptr + FRM_OFFSET_H)

    frmx1=frmx+frmw-1
    frmy1=frmy+frmh-1

    frame_dblup_addr(frameidx) = dblup_addr

    ' COPY COLOR for each row twice into some location in dblup_addr
    for y = frmy to frmy1
      for k = 0 to 1
          ' copy it to some place in $5.2000
          edma 0, frmw, (ptr + FRM_OFFSET_DATA), dblup_addr
          dblup_addr = dblup_addr + frmw
      next k
      ptr = ptr + frmw
    next y

  next frameidx

  return


'---------------
.draw_background
'---------------
   '   frameidx = IMG_SUN
   '   gosub draw_petscii_layer 
   '   return

  poke $4000b, $05  ' assure source bank 5 (for doubled-up layers)

  for lidx = 0 to max_frames(FORM_LAYER)-1
     ' if layer_visible[lidx] = 1 then begin
       frameidx = draw_order(lidx)
       gosub draw_petscii_layer 
     'bend
  next lidx

  return


'----------
.move_right
'----------
  baddie_visible = baddie_state = BS_ALIVE or baddie_state = BS_DEAD

  if px < 25 or (baddie_state = BS_ALIVE and px < 59) then begin
    px = px + 1
  bend:else begin
    if bx > 0 and baddie_visible then begin
      gosub incr_offs

      bx = bx - 1
    bend
    if baddie_state = BS_OFF then begin
      gosub incr_offs
    bend
  bend

  if baddie_state <> BS_ALIVE and px > 26 then begin
    if mod(player_frame,2) = 0 then px = px - 1
  bend


  kneel_flag = 0
  return


'---------
.move_left
'---------
  if px > 0 then begin
    px = px - 1
  bend:else begin
    if bx < 60 then begin
      gosub decr_offs
      bx = bx + 1
    bend
  bend

  kneel_flag = 0
  return


'--------------
.get_user_input
'--------------
  gosub keyboard_input

  gosub joystick_input

  if a$="x" then begin
    kneel_flag = 0
    player_anim = form_anim(player_form, FANIM_DIE)
    player_frame = 0
  bend

  return


'--------------
.keyboard_input
'--------------
  get a$

  if a$="," and palidx>0 then palidx=palidx-1:gosub set_palette
  if a$="." and palidx<11 then palidx=palidx+1:gosub set_palette

  if a$="1" then begin
    DEBUG=mod(DEBUG+1,2)
    edma 3, $f00, 160, $50000
    edma 3, $f00, 160, $40800

  bend

  ' d = toggle between human and duck
  if a$="d" then begin
    if player_form = FORM_HUMAN then begin
      player_form = FORM_DUCK
      player_dat_idx = DAT_DUCK
    bend:else begin
      player_form = FORM_HUMAN
      player_dat_idx = player_dat_fixed
    bend
    player_anim = form_anim(player_form, FANIM_WALK)
    player_frame = 0
    kneel_flag = 0
  bend

  if a$="<" and player_dat_fixed > DAT_PLAYER1 then begin
    player_dat_fixed = player_dat_fixed - 1
    player_dat_idx = player_dat_fixed
  bend
  if a$=">" and player_dat_fixed < DAT_PLAYER4 then begin
    player_dat_fixed = player_dat_fixed + 1
    player_dat_idx = player_dat_fixed
  bend
  return

'--------------
.joystick_input
'--------------
  jdir_raw = joy(2)
  jfire = jdir_raw and 128
  jdir = jdir_raw and $7f
  if jdir > 8 then jdir = 0  ' hide any nonsensicals

  ' handle no joystick input cases
  ' ------------------------------
  if jdir_raw=0 and player_anim = ANIM_PKNEEL_DN then begin
    if player_frame >= max_frame(FORM_HUMAN, ANIM_PKNEEL_DN)-1 then begin
    kneel_flag = 0
    player_anim = ANIM_PKNEEL_UP
    player_frame = 0
    bend
  bend
  if jdir_raw = 0 then return

  ' handle cases with some joystick input
  ' -------------------------------------

  ' no fire button moves
  ' --------------------
  if jfire=0 then begin
    if jdir=J_RIGHT and pjump=0 then gosub move_right
    if jdir=J_LEFT and pjump=0 then gosub move_left
    if jdir=J_DOWN and player_anim = ANIM_PWALK then begin
      player_anim = ANIM_PKNEEL_DN
      player_frame = 0
    bend
    if jdir=J_UP and pjump=0 then begin
      player_anim = ANIM_PJUMP
      pjump = 1
      player_frame = 0
    bend
  bend

  ' fire button moves
  ' -----------------
  if jfire = 128 and pjump=0 then begin
    if jd(player_mirror, jdir)=JD_UP_FORWARD and player_anim = form_anim(player_form, FANIM_WALK) then begin
      player_anim = form_anim(player_form, FANIM_PUNCH)
      sound 1 + player_mirror * 3, 4000, 5, 1, 100, 1000, 3
      if kneel_flag = 1 then player_anim = ANIM_PKPUNCH
      player_frame = 0
    bend
    if jd(player_mirror, jdir)=JD_DOWN_FORWARD and player_anim = ANIM_PWALK then begin
      player_anim = ANIM_PKICK
      sound 1 + player_mirror * 3, 2000, 5, 1, 100, 1000, 3
      if kneel_flag = 1 then player_anim = ANIM_PKKICK
      player_frame = 0
    bend
  bend
  return


'-----------
.draw_player
'-----------
  character = PLAYER
  frameidx = anim_order(player_form, player_anim, player_frame)
  fx=px : fy=py
  mirror = player_mirror
  form = player_form
  dat_idx = player_dat_idx
  gosub draw_petscii_frame

  return


'-----------
.draw_baddie
'-----------
  character = BADDIE
  frameidx = anim_order(baddie_form, baddie_anim, baddie_frame)
  fx=bx : fy=by
  mirror = baddie_mirror
  form = baddie_form
  dat_idx = baddie_dat_idx
  gosub draw_petscii_frame
  return


'--------------------------
.consider_next_player_frame
'--------------------------
  if player_anim = form_anim(player_form, FANIM_WALK) and (jdir=J_LEFT or jdir=J_RIGHT) then begin
    player_frame = player_frame + 1
  bend
  if player_anim <> form_anim(player_form, FANIM_WALK) then begin
    player_frame = player_frame + 1
  bend

  if player_anim = ANIM_PKNEEL_DN and jdir=J_DOWN then begin
    if player_frame >= max_frame(FORM_HUMAN, FANIM_KNEEL_DN) then begin
      player_frame = max_frame(FORM_HUMAN, FANIM_KNEEL_DN) - 1
      kneel_flag = 1
    bend
    return
  bend

  if player_anim = ANIM_PJUMP then begin
    if player_frame >= max_frame(FORM_HUMAN, FANIM_JUMP) then begin
      player_frame = max_frame(FORM_HUMAN, FANIM_JUMP) - 1
    bend
  bend

  if pjump > 0 then begin
    if pjump = 1 then begin
      py = py - 2
      if py <= 0 then pjump = 2
    bend
    if pjump = 2 then begin
      py = py + 2
      if py >= 23 then begin
        py = 23
        pjump = 0
        player_anim = form_anim(player_form, FANIM_WALK)
        player_frame = 0
      bend
    bend
  bend

  if player_frame >= max_frame(player_form, player_anim) then begin
    if player_anim = ANIM_PDIE then begin
      if player_energy > 0 then begin
        player_anim = ANIM_PKNEEL_UP
        player_frame = 0
      bend:else begin
        player_frame = max_frame(player_form, player_anim) - 1
      bend
      return
    bend
    if kneel_flag = 1 and player_anim <> ANIM_PKNEEL_DN then begin
      player_anim = ANIM_PKNEEL_DN
      player_frame = max_frame(FORM_HUMAN, ANIM_PKNEEL_DN) - 1
    bend:else begin
      player_anim = form_anim(player_form, FANIM_WALK)
      player_frame = 0
    bend
  bend

  if baddie_state = BS_ALIVE or baddie_state = BS_DEAD then begin
    if px > (bx + 5) then player_mirror = 1
    if bx > (px + 5) then player_mirror = 0
  bend:else begin
    player_mirror = 0
  bend

  return

'--------------------------
.consider_next_baddie_frame
'--------------------------
  if baddie_state = BS_ALIVE then begin
    if bx > (px + 5) then baddie_mirror = 1
    if px > (bx + 5) then baddie_mirror = 0
  bend

  if baddie_anim <> ANIM_PWALK then begin
    baddie_frame = baddie_frame + 1
  bend

  if baddie_frame >= max_frame(baddie_form, baddie_anim) then begin
    if baddie_anim = ANIM_PDIE then begin
      if baddie_energy > 0 then begin
        baddie_anim = ANIM_PKNEEL_UP
        baddie_frame = 0
      bend:else begin
        baddie_frame = max_frame(baddie_form, baddie_anim) - 1
      bend
      return
    bend
    if baddie_kneel_flag = 1 and baddie_anim <> ANIM_PKNEEL_DN then begin
      baddie_anim = ANIM_PKNEEL_DN
      baddie_frame = max_frame(FORM_HUMAN, ANIM_PKNEEL_DN) - 1
    bend:else begin
      baddie_anim = form_anim(baddie_form, FANIM_WALK)
      baddie_frame = 0
    bend
    return
  bend

  if baddie_state <> BS_ALIVE then return
  if baddie_anim = ANIM_PDIE then return

  gosub if_player_far_walk_closer
  if ret% = 1 then return

  gosub if_player_nearer_walk_cautious
  if ret% = 1 then return

  gosub if_player_hittable_try_hitting
  if ret% = 1 then return

  ' if player is trying to hit me, consider fleeing

  return

'------------------------------
.if_player_hittable_try_hitting
'------------------------------
  ret% = 0
  ' if player is within hitting distance, consider hitting
  if abs(px-bx) >= 8 and baddie_anim = ANIM_PWALK then begin
    ret% = 1
    k = int(rnd(1)*8)
    if k = 1 then begin
      baddie_anim = ANIM_PPUNCH
      baddie_frame=0
      sound 1 + baddie_mirror * 3, 4000, 5, 1, 100, 1000, 3
    bend
    if k = 2 then begin
      baddie_anim = ANIM_PKICK
      baddie_frame=0
      sound 1 + baddie_mirror * 3, 2000, 5, 1, 100, 1000, 3
    bend

  bend
  return

'------------------------------
.if_player_nearer_walk_cautious
'------------------------------
  ret% = 0
  ' if player is nearer, walk ahead more cautiously
  if abs(px-bx) > 8 then begin
    if int(rnd(1)*4) >= 3 then gosub move_baddie_closer
    ret% = 1
  bend
  return

'-------------------------
.if_player_far_walk_closer
'-------------------------
  ret% = 0
  ' if player is a long distance away, commit to walking closer
  if abs(px-bx) > 20 then begin
    gosub move_baddie_closer
    ret% = 1
  bend
  return


'------------------
.move_baddie_closer
'------------------
  baddie_anim = ANIM_PWALK
  baddie_frame = baddie_frame + 1
  if baddie_frame >= max_frame(baddie_form, baddie_anim) then baddie_frame = 0

  if bx > px then begin
    bx = bx - 1
  bend:else begin
    bx = bx + 1
  bend
  return

'------------------
.draw_petscii_frame
'------------------
  poke $4000b, $04  ' assure source bank 4 (for original frame data)
  if mirror = 1 then setbit $40006, 5:else clrbit $40006, 5
  data_addr = frame_addr(dat_idx, frameidx)
  frmx = peek(data_addr + FRM_OFFSET_X)
  frmy = peek(data_addr + FRM_OFFSET_Y)
  frmw = peek(data_addr + FRM_OFFSET_W)
  frmh = peek(data_addr + FRM_OFFSET_H)

  frmx = fx ' override position
  frmy = fy

  frmx1=frmx+frmw-1
  frmy1=frmy+frmh-1

  clraddr = $51000 + frmx + frmy * 80
  if mirror = 1 then clraddr = clraddr + frmw - 1

  cdata_addr = data_addr + FRM_OFFSET_DATA

  for yy=frmy to frmy1

    ' draw chars
    ' ----------
    src_addr = cdata_addr
    dest_addr = clraddr
    length = frmw
    transp = $ff
    gosub transparent_dma

    cdata_addr = cdata_addr + frmw
    clraddr = clraddr + 80  
  next yy

  if DEBUG then gosub draw_boxes

  gosub check_if_hit_opponent

  return


'------------------
.draw_petscii_layer
'------------------
  clrbit $40006, 5
  data_addr = frame_addr(DAT_LAYER, frameidx)
  frmx = peek(data_addr + FRM_OFFSET_X)
  frmy = peek(data_addr + FRM_OFFSET_Y)
  frmw = peek(data_addr + FRM_OFFSET_W)
  frmh = peek(data_addr + FRM_OFFSET_H)

  frmx1=frmx+frmw-1
  frmy1=frmy+frmh-1

  clraddr = $51000 + frmx + frmy * 80
  cdata_addr = data_addr + FRM_OFFSET_DATA + frmw * frmh

  xoffs(frameidx) = mod(xoffs(frameidx) + 80, 80)
  xoffs = int(xoffs(frameidx))

  cdata_addr = frame_dblup_addr(frameidx)

  for yy=frmy to frmy1

    ' draw chars from offset to end
    ' -----------------------------
    src_addr = cdata_addr + xoffs
    dest_addr = clraddr
    length = frmw
    transp = $ff
    gosub transparent_dma

    cdata_addr = cdata_addr + frmw * 2
    clraddr = clraddr + 80  
  next yy
  return


'--------
.gameplay
'--------
  gosub get_user_input
  gosub draw_background
  gosub draw_sprites
  gosub page_flip
  gosub game_logic
  gosub draw_energy_bars

  ret% = 0
  do while ret% = 0
    gosub parse_current_seqptr
  loop

  goto gameplay
  return

'----------------
.draw_energy_bars
'----------------
  if player_energy <> lag_penergy then begin
    if lag_penergy < player_energy then begin
      lag_penergy = lag_penergy + 1
      k = lag_penergy
      gosub draw_blue_triangle
      return
    bend
    if lag_penergy > player_energy then begin
      k = lag_penergy
      gosub clear_blue_triangle
      lag_penergy = lag_penergy - 1
      return
    bend
  bend

  if baddie_energy <> lag_benergy then begin
    if lag_benergy < baddie_energy then begin
      lag_benergy = lag_benergy + 1
      k = lag_benergy
      gosub draw_red_triangle
      return
    bend
    if lag_benergy > baddie_energy then begin
      k = lag_benergy
      gosub clear_red_triangle
      lag_benergy = lag_benergy - 1
      return
    bend
  bend

  return

'------------------
.draw_blue_triangle
'------------------
  cursor 1 + k * 2, 48:print "{x9A}{x12}ß";
  cursor 1 + k * 2, 49:print "{x1F}{x92}©";
  return

'-------------------
.clear_blue_triangle
'-------------------
  cursor 1 + k * 2, 48:print "{x92} ";
  cursor 1 + k * 2, 49:print "{x92} ";
  return

'-----------------
.draw_red_triangle
'-----------------
  cursor 78 - k * 2, 48:print "{x96}{x12}©";
  cursor 78 - k * 2, 49:print "{x1C}{x92}ß";
  return

'------------------
.clear_red_triangle
'------------------
  cursor 78 - k * 2, 48:print "{x92} ";
  cursor 78 - k * 2, 49:print "{x92} ";
  return

'------------
.draw_sprites
'------------
  if baddie_state = BS_ALIVE or baddie_state = BS_DEAD then begin
    gosub draw_baddie
  bend
  gosub draw_player
  return

'----------
.game_logic
'----------
  gosub consider_next_player_frame
  gosub assess_baddie_state

  return

'-------------------
.assess_baddie_state
'-------------------
  if baddie_state = BS_OFF then begin
    ' consider when to spawn next baddie
    next_baddie_time = next_baddie_time - 1
    if next_baddie_time = 0 then baddie_state = BS_SPAWN
    return
  bend

  if baddie_state = BS_SPAWN then begin
    baddie_form = FORM_HUMAN
    if baddie_dat_fixed = DAT_PLAYER2 then begin
      baddie_dat_fixed = DAT_PLAYER3
    bend: else begin
      baddie_dat_fixed = DAT_PLAYER2
    bend
    baddie_dat_idx = baddie_dat_fixed
    baddie_state = BS_ALIVE

    bx = 60 : by = 23

    baddie_anim = form_anim(baddie_form, FANIM_WALK)
    baddie_frame = 0
    baddie_energy = 18
    lag_benergy = 0
    baddie_mirror = 1
    bjump = 0

    return
  bend

  if baddie_state = BS_ALIVE then begin
    gosub consider_next_baddie_frame
    if baddie_energy = 0 then baddie_state = BS_DEAD: baddie_dead_time=50
    return
  bend

  if baddie_state = BS_DEAD then begin
    gosub consider_next_baddie_frame
    player_mirror = 0
    baddie_dead_time = baddie_dead_time - 1
    if baddie_dead_time = 0 then baddie_state = BS_OFF:next_baddie_time=50
    return
  bend
  return


'---------
.page_flip
'---------
  if DEBUG then begin
    edma 0, $f00, $50000, $40800
    edma 3, $f00, 160, $50000
  bend
  edma 0, $f00, $51000, $ff80000

  ' fill the top part
  edma 3, $f00, $4f, $51000
  return

'---------
.incr_offs
'---------
  for k = 0 to HIGHEST_LAYER
    xoffs(k) = xoffs(k) + offs_amount(k)
  next k
  return

'---------
.decr_offs
'---------
  for k = 0 to HIGHEST_LAYER
    xoffs(k) = xoffs(k) - offs_amount(k)
  next k
  return


'----------
.draw_boxes
'----------
  ptr = data_addr + FRM_OFFSET_HITBOXES

  for idx = 0 to 3
    x1 = peek(ptr + 0)
    y1 = peek(ptr + 1)
    x2 = peek(ptr + 2)
    y2 = peek(ptr + 3)

    if not (x1=0 and y1=0 and x2=0 and y2=0) then begin
      gosub adjust_coords

      draw_color = 7

      if idx = 3 then begin
        draw_color = 2
        gosub draw_box
        ' gosub check_if_hit_opponent
      bend:else begin
        gosub draw_box
      bend

    bend

    ptr = ptr + 4
  next idx
  return


'--------
.draw_box
'--------
  ' draw corners
  ' ------------
  x = x1 : y = y1 : k = CHAR_BOX_TL : gosub draw_char
  x = x2 : y = y1 : k = CHAR_BOX_TR : gosub draw_char
  x = x1 : y = y2 : k = CHAR_BOX_BL : gosub draw_char
  x = x2 : y = y2 : k = CHAR_BOX_BR : gosub draw_char

  ' draw horizontals
  ' ----------------
  for x = x1+1 to x2-1
    y = y1 : k = CHAR_HORZ : gosub draw_char
    y = y2 : k = CHAR_HORZ : gosub draw_char
  next x

  ' draw verticals
  ' --------------
  for y = y1+1 to y2-1
    x = x1 : k = CHAR_VERT : gosub draw_char
    x = x2 : k = CHAR_VERT : gosub draw_char
  next y

  return


'---------
.draw_char
'---------
  if peek($50000 + x + y * 80) <> CHAR_SPACE then begin
    k = k + 128
  bend:else begin
    poke $51000 + x + y * 80, 1
  bend
  if draw_color = 2 then poke $51000 + x + y * 80, draw_color
  poke $50000 + x + y * 80, k
  return


'---------------------
.check_if_hit_opponent
'---------------------
  data_addr = frame_addr(dat_idx, frameidx)

  tmp_mirror = mirror
  if character = PLAYER then begin
    frameidx = anim_order(baddie_form, baddie_anim, baddie_frame)
    opponent_data_addr = frame_addr(baddie_dat_idx, frameidx)
    opponent_mirror = baddie_mirror
    fx=bx : fy=by
  bend
  if character = BADDIE then begin
    frameidx = anim_order(player_form, player_anim, player_frame)
    opponent_data_addr = frame_addr(player_dat_idx, frameidx)
    opponent_mirror = player_mirror
    fx=px : fy=py
  bend

  x1 = peek(data_addr + FRM_OFFSET_HB_ATTACK + 0)
  y1 = peek(data_addr + FRM_OFFSET_HB_ATTACK + 1)
  x2 = peek(data_addr + FRM_OFFSET_HB_ATTACK + 2)
  y2 = peek(data_addr + FRM_OFFSET_HB_ATTACK + 3)

  if x1=0 and y1=0 and x2=0 and y2=0 then return

  gosub adjust_coords
  p_x1 = x1
  p_y1 = y1
  p_x2 = x2
  p_y2 = y2

  frmx = peek(opponent_data_addr + FRM_OFFSET_X)
  frmy = peek(opponent_data_addr + FRM_OFFSET_Y)
  frmx = frmx + fx
  frmy = frmy + fy

  frmw = peek(opponent_data_addr + FRM_OFFSET_W)
  frmh = peek(opponent_data_addr + FRM_OFFSET_H)


  ' iterate through head/torso/feet hitboxes of opponent
  ptr = opponent_data_addr + FRM_OFFSET_HITBOXES

  for idx = 0 to 2
    x1 = peek(ptr + 0)
    y1 = peek(ptr + 1)
    x2 = peek(ptr + 2)
    y2 = peek(ptr + 3)

    gosub adjust_coords
    o_x1 = x1
    o_y1 = y1
    o_x2 = x2
    o_y2 = y2

    gosub check_box_collision

    if ret% = 1 then begin
      if character = BADDIE then begin
        player_anim = form_anim(player_form, FANIM_DIE)
        player_frame = 0
        if player_energy > 0 then player_energy = player_energy - 1
        if player_energy = 0 then begin
          sound 1 + player_mirror * 3, 8000, 50, 1, 435, 100, 0, 4000
        bend:else begin
          sound 1 + player_mirror * 3, 8000, 10, 1, 435, 200, 0, 4000
        bend
      bend
      if character = PLAYER then begin
        baddie_anim = form_anim(baddie_form, FANIM_DIE)
        baddie_frame = 0
        if baddie_energy > 0 then baddie_energy = baddie_energy - 1
        if baddie_energy = 0 then begin
          sound 1 + baddie_mirror * 3, 8000, 50, 1, 435, 100, 0, 4000
        bend:else begin
          sound 1 + baddie_mirror * 3, 8000, 10, 1, 435, 200, 0, 4000
        bend
      bend
      idx = 2  ' force bail out of for-loop upon any hit
    bend
    ptr = ptr + 4
  next idx

  mirror = tmp_mirror
  ptr = frame_addr(dat_idx, frameidx)
  return


'-------------
.adjust_coords
'-------------
  if mirror = 0 then begin
    x1 = frmx + x1
    y1 = frmy + y1
    x2 = frmx + x2
    y2 = frmy + y2
  bend:else begin
    tmpx1 = x1
    x1 = frmx + frmw - x2 - 1
    y1 = frmy + y1
    x2 = frmx + frmw - tmpx1 - 1
    y2 = frmy + y2
  bend
  return


'-------------------
.check_box_collision
'-------------------
  'print "{x13}";chr$(27);"q";p_x1;p_y1;p_x2;p_y2
  'print chr$(27);"q";o_x1;o_y1;o_x2;o_y2;
  'get key a$

  if not ((o_x1 > p_x2) or {x5F}
          (o_x2 < p_x1) or {x5F}
          (o_y1 > p_y2) or {x5F}
          (o_y2 < p_y1)) then {x5F}
  begin
    ret% = 1
  bend:else begin
    ret% = 0
  bend
  return

'---------
.load_song
'---------
  dopen #2,(song$),r,u8

  ' load melody chunks
  ' ------------------
  input #2, chunk_cnt
  for chunk_idx = 0 to chunk_cnt - 1
    for vidx=0 to 5
      input #2,v$(vidx, chunk_idx)
    next vidx
  next chunk_idx

  input #2,tmpo%
  
  ' load envelopes
  ' --------------
  for row = 0 to 9
    input #2, envs_name$(row)
    input #2, envs_attack(row)
    input #2, envs_decay(row)
    input #2, envs_sustain(row)
    input #2, envs_release(row)
    input #2, envs_waveform(row)
    input #2, envs_pw(row)
    gosub set_env
  next row
  print

  ' load filter presets
  ' -------------------
  for row = 0 to 10
    input #2, filt_name$(row)
    input #2, filt_freq(row)
    input #2, filt_lp(row)
    input #2, filt_bp(row)
    input #2, filt_hp(row)
    input #2, filt_res(row)
    input #2, filt_dir(row)
    input #2, filt_min(row)
    input #2, filt_sweep(row)
  next row

  ' load sequence
  ' -------------
  seqcnt = 0
  input #2, seqcnt
  row = 0
  do while row < seqcnt
    input #2, seq_chunk(row)
    input #2, seq_extra(row)
    row = row + 1
  loop


  dclose #2

  chunk_idx = 0
  return


'-------
.set_env
'-------
  envelope row, envs_attack(row), envs_decay(row), envs_sustain(row), envs_release(row), envs_waveform(row), envs_pw(row)
  return


'--------------------
.parse_current_seqptr
'--------------------
  ret% = 0
  if rplay(1)<>0 then ret%=1:return

  k = seq_chunk(plyptr)
  
  if k >= 0 then begin
    chunk_idx = k
    if chunk_rpt <= 0 then chunk_rpt = seq_extra(plyptr)
    gosub play_chunk_idx
    'sleep .1
    ret% = 1
  bend
  if k = CMD_TEMPO then begin
    k = seq_extra(plyptr)
    tempo (k)
    tmpo% = k
  bend
  if k = CMD_FILTER then begin
    k = seq_extra(plyptr)
    fsrow = k
    fsel = k
    gosub apply_selected_filter
  bend
  if k = CMD_ECHO_M1 then echo_m = 1 : echo_delay = 0
  if k = CMD_ECHO_M2 then echo_m = 2 : echo_delay = 0
  if k = CMD_ECHO_B  then echo_b = 1 : echo_delay = 0
  if k = CMD_ECHO_OFF then echo_m = 0 : echo_b = 0
  if k = CMD_ECHO_SZ then echo_sz = seq_extra(plyptr)
  if k = CMD_DELAY then echo_delay = 1 : echo_m = 0 : echo_b = 0

  if k = CMD_VOL then v = seq_extra(plyptr) : vol v, v

  if chunk_rpt > 0 then chunk_rpt = chunk_rpt - 1

  if chunk_rpt <= 0 then plyptr = plyptr + 1

  if k = CMD_LOOP then plyptr = 0

  if plyptr >= seqcnt then plyflag = 0 : plyptr = -1
  return


'--------------
.play_chunk_idx
'--------------
  v1$ = v$(0,chunk_idx)
  v2$ = v$(1,chunk_idx)
  v3$ = v$(2,chunk_idx)
  v4$ = v$(3,chunk_idx)
  v5$ = v$(4,chunk_idx)
  v6$ = v$(5,chunk_idx)

  if echo_delay = 1 then begin
    play v1$
    sleep (echo_sz)
    play ,v2$
    sleep (echo_sz)
    play ,,v3$
    sleep (echo_sz)
    play ,,,v4$
    sleep (echo_sz)
    play ,,,,v5$
    sleep (echo_sz)
    play ,,,,,v6$
    sleep (echo_sz)
    return
  bend

  if echo_m = 0 and echo_b = 0 then begin
    play v1$, v2$, v3$, v4$, v5$, v6$
    return
  bend

  if echo_m = 1 and echo_b = 0 then begin
    play v1$, v2$, v3$,    , v5$, v6$
    sleep (echo_sz)
    play    ,    ,    , v1$
  bend

  if echo_m = 1 and echo_b = 1 then begin
    play v1$, v2$, v3$,    , v5$
    sleep (echo_sz)
    play    ,    ,    , v1$,    , v3$
  bend

  if echo_m = 2 and echo_b = 0 then begin
    play v1$,    , v3$,    ,    , v6$
    sleep (echo_sz)
    play    ,    ,    , v1$
    sleep (echo_sz)
    play    , v1$
    sleep (echo_sz)
    play    ,    ,    ,    , v1$
  bend

  if echo_m = 2 and echo_b = 1 then begin
    play v1$,    , v3$
    sleep (echo_sz)
    play    ,    ,    , v1$
    sleep (echo_sz)
    play    , v1$,    ,    ,    , v3$
    sleep (echo_sz)
    play    ,    ,    ,    , v1$
  bend

  return


'---------------------
.apply_selected_filter
'---------------------
  if fsel = -1 then return

  curr_freq = filt_freq(fsel)
  curr_dir = DIR_NONE
  if   filt_dir(fsel) = DIR_UP {x5F}
    or filt_dir(fsel) = DIR_OSC then begin
    curr_freq = filt_min(fsel)
    curr_dir = DIR_UP
  bend
  if filt_dir(fsel) = DIR_DOWN then begin
    curr_dir = DIR_DOWN
  bend

  filter 1, filt_freq(fsel), filt_lp(fsel), {x5F} 
         filt_bp(fsel), filt_hp(fsel), filt_res(fsel)
  filter 2, filt_freq(fsel), filt_lp(fsel), {x5F} 
         filt_bp(fsel), filt_hp(fsel), filt_res(fsel)

  return
ÿ